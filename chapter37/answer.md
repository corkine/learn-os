rotate for 1 degree/timeunit, 12 one circle, 360 degree, each 2-point need 30 timeunit
seek for 40 distance/timeunit, each track have 40 distance

1.
-a 0 -> 30 * 5.5 = 165 for rotate, 0 for seek, 30 for trans, 195 for total
-a 6 -> 30 * 11.5 = 345 for rotate, 0 for seek, 30 for trans, 375 for total
-a 30 -> 40 * 2 = 80 for seek, 345 - 80 = 265 for rotate, 30 for trans, 375 for total
-a 7,30,8 -> 
    7 -> rotate 15, seek 0, trans 30, total 45, current 7.5
    30-> seek 80, rotate 220, trans 30, total 330, current 30.5
    8 -> seek 80, rotate 30 - 80 < 0, 360 + 30 - 80 = 310, trans 30, total 420
    total seek 160, rotate 545, trans 90, total 795
-a 10,11,12,13
    10 -> seek 0, rotate 3.5 * 30 = 105, trans 30, total 135
    11 -> seek 0, rotate 0, trans 30, total 30
    12 -> seek 40, rotate 320, trans 30, total 390
    13 -> seek 0, rotate 0, trans 30, total 30
    total seek 40, rotate 425, trans 120, total 585

2.
寻道速度加快不仅能降低寻道时间，并且对于旋转时间和总时间都能产生影响：
disk.py -a 10,11,12,13 -S 0.1 -G
disk.py -a 10,11,12,13 -S 2 -G
对于跨磁道的连续块，寻道时间再短还是要转一圈，相反，寻道时间再慢，只要
在转一圈的旋转耗时之内成功变道，其旋转耗时和总的耗时都不会变化。
disk.py -a 7,30,8 -S 0.1 -G
disk.py -a 7,30,8 -S 2 -G
对于随机读写而言，寻道速度快确确实实在大部分情况（少部分因为速度相对于目标还是慢）
下提升了降低了跨道的旋转耗时，降低了总时间。

3.
旋转速率越慢，旋转耗时越长，对于连续读写而言，旋转速率再慢跨道还是会转一圈，不影响成比例的总时间。对于随机读写而言一些之前因为换道不得不额外转一圈的请求现在可能不需要了，部分降低了成比例的总时间，但总的来说，因为旋转非常常用，远大于磁盘换道的操作，降低旋转时间，总时间基本上都下降的比较厉害。

4.
策略的影响，对于 FIFO 调度 7,30,8，其不得不转换 4 次磁道，耗时 795，
但如果采用 SSTF 则仅需要 375，这里 7 和 8 seek 和 rotate 都为 0，只有
传输时间，只有调度 30 时才有 80 的 seek 和一定的 rotate 和 trans。

5.
使用 SATF 调度 7,30,8 和使用 SSTF 没有影响
对于 7,22,2 而言，SATF 会优先 7 -> 22 -> 2 245 时间完成调度
SSTF 则使用了 7 -> 2 -> 22 495 时间完成调度
只要存在这种能有效通过换道减少空转磁盘的序列（换道快于空转），SATF 相比较 SSTF 都更优优势

6.
因为这些连续数字出现在了不同磁道上，使用默认旋转和寻道速率，寻道切换需要 40 tu，
那么偏移至少也要有 2 blocks，因为旋转 1 个节点需要 30tu
disk.py -a 10,11,12,13 -o 2
从 585 减少到了 285
实际上考虑 S 为 s，则需要偏移的 blocks 为 cell(40 / s * 30)
比如 S = 2，需要偏移 1，S = 4，需要偏移 1

7.
-a -1 表示使用随机请求，-A 表示生成 -1 到 0 的五个请求
-z 10,20,30 表示多区域磁盘从外到内不同磁道内，每个磁道所占的角度空间
disk.py -z 10,20,30 -a -1 -A 5,-1,0 -s 1 -G
7,45,41,13,26
从最外层磁道的 18 开始，7 需要 (36 + 7 - 0.5 - 18) * 10 = 245 rotate, 0 seek, 10 trans，之后落到 7.5 上，开始向内 seek 去 45，中间一层每个间隔需要 20s，7.5 对应 39.75，
其在一次 seek 的时间内可走 2 格，因此到 45 除了 40 seek 还需要 (45 - 0.5 - 39.75) * 20 = 95 - 40 = 55 时间，传输需要 20 时间，然后需要到 41，seek 0，中间层一共 18 个扇区，rotate 需要 (41 - 0.5 + 18 - 45.5) * 20 = 260 - 20 = 240 时间，然后需要去 13, 41.5 对应的是 11，按照外层的速度，seek 40 可以走到 15，因此这里还需要轮空一圈，总的来说需要 (11 + 36 - 12.5) * 10 = 345 - 10 = 335 时间，之后需要到 26，seek 0，只需要转 (25.5 - 13.5) * 10 = 120 时间即可，
总的来说，需要执行的 seek 为 40，trans 为 70，rotate 为 245 + 55 + 240 + 335 + 120 = 991，合计 1165 时间。

8.
C:\Python27\python.exe disk.py -A 1000,-1,0 -c -p SATF -s 1 -w 1
当调度窗口很小的时候，总的耗时很大，调度窗口增大，耗时减少，但大到一定程度，耗时不会
继续减少，此时还会有延迟增加的风险。

9.
每次间隔访问两个相差很大的扇区导致饥饿，使用 BSATF 算法窗口，-w 的指定非常关键
其需要打破间隔长度才能避免饥饿。

10.
上述间隔访问相差很大的扇区就会导致问题，如果可以间隔的选择处理，就能得到更好的性能
比如 1,100,2,101,3,102 -> 1,2,3,100,101,102